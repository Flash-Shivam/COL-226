(* Type definition for the expression parse tree generated by the parser *)
type expr_tree = NULL | VAR of char | NUM of int | Assign of (expr_tree * expr_tree) | Call of (expr_tree * expr_tree ) | Tup of (expr_tree * expr_tree ) | RETURN | FUNC of char | Display of expr_tree;;

exception Empty 
(* Map from string variable names to their integer values. New values can be added *)
module VarTable = Map.Make(Char)
let variable_set = VarTable.(empty);;
let temp = ref variable_set;;

module ETable = Map.Make(Char)
let e_set = ETable.(empty);;
let e_temp = ref e_set;;

let f x = x;;

module PTable = Map.Make(Char)
let p_set = VarTable.map f !temp;;
let p_temp = ref p_set;;

module QTable = Map.Make(Char)
let q_set = VarTable.map f !temp;;
let q_temp = ref q_set;;

module TTable = Map.Make(Char)
let t_set = QTable.map f !q_temp;;
let t_temp = ref t_set;;

module UTable = Map.Make(Char)
let u_set = QTable.map f !q_temp;;
let u_temp = ref u_set;;

module WTable = Map.Make(Char)
let w_set = TTable.map f !t_temp;;
let w_temp = ref w_set;;

module RTable = Map.Make(Char)
let r_set = PTable.map f !p_temp;;
let r_temp = ref r_set;;

module STable = Map.Make(Char)
let s_set = PTable.map f !p_temp;;
let s_temp = ref s_set;;

module VTable = Map.Make(Char)
let v_set = RTable.map f !r_temp;;
let v_temp = ref v_set;;


let empty = ['M'] ;;
let l = ref empty;;

let stack = ['M'] ;;
let st = ref stack;;


let rec map fn l = match l with
    [] -> []
    | x::xs -> (fn x)::(map fn xs)
;;


let rec pr x = match x with 
[] ->  Printf.printf " "  ;
| p :: q -> print_char p ; Printf.printf " " ; pr q 
;;

let rec prr x = match x with 
[] ->  Printf.printf " "  ;
| (p,m) :: q -> print_char(p)  ; Printf.printf ": " ; print_int(m) ; Printf.printf ", " ; prr q 
;;


let rec eval_tree q = match q with
    NULL           -> raise Empty
    | Assign(VAR(x),y) -> ( match (!l) with a :: b ->  ( match a with 'M' -> (match y with NUM(z) -> if (x == 'a' || x == 'b' || x == 'c') then (temp := (VarTable.add (x) (z) (!temp))) else Printf.printf "Can't be done"; 
	| VAR(z) -> if (z == 'a' || z == 'b' || z == 'c') then ( temp := (VarTable.add (x) (VarTable.find (z) (! temp)) (!temp))) else Printf.printf "Can't be done"; )
| 'P' -> (match y with NUM(z) -> if (x == 'a' || x == 'b' || x == 'c' || x == 'y' || x == 'x' || x == 'z') then (p_temp := (VarTable.add (x) (z) (!p_temp))) else Printf.printf "Can't be done"; 
	| VAR(z) -> if (z == 'a' || z == 'b' || z == 'c' || z == 'y' || z == 'x' || z == 'z') then ( p_temp := (VarTable.add (x) (VarTable.find (z) (!p_temp)) (!p_temp))) else Printf.printf "Can't be done"; )
| 'R' -> (match y with NUM(z) -> if (x == 'a' || x == 'b' || x == 'c' || x == 'y' || x == 'x' || x == 'z' || x == 'w' || x == 'i' || x == 'j') then (r_temp := (VarTable.add (x) (z) (!r_temp))) else Printf.printf "Can't be done"; 
	| VAR(z) -> if (z == 'a' || z == 'b' || z == 'c' || z == 'y' || z == 'x' || z == 'z' || z == 'w' || z == 'i' || z == 'j') then ( r_temp := (VarTable.add (x) (VarTable.find (z) (!r_temp)) (!r_temp))) else Printf.printf "Can't be done"; )
| 'V' -> (match y with NUM(z) -> if (x == 'a' || x == 'b' || x == 'c' || x == 'y' || x == 'x' || x == 'z' || x == 'w' || x == 'i' || x == 'j' || x == 'm' || x == 'n') then (v_temp := (VarTable.add (x) (z) (!v_temp))) else Printf.printf "Can't be done"; 
	| VAR(z) -> if (z == 'a' || z == 'b' || z == 'c' || z == 'y' || z == 'x' || z == 'z' || z == 'w' || z == 'i' || z == 'j'|| z == 'm' || z == 'n') then ( v_temp := (VarTable.add (x) (VarTable.find (z) (!v_temp)) (!v_temp))) else Printf.printf "Can't be done"; )
| 'S' -> (match y with NUM(z) -> if (x == 'a' || x == 'b' || x == 'c' || x == 'y' || x == 'x' || x == 'z' || x == 'm' || x == 'n' || x == 'k') then (s_temp := (VarTable.add (x) (z) (!s_temp))) else Printf.printf "Can't be done"; 
	| VAR(z) -> if (z == 'a' || z == 'b' || z == 'c' || z == 'y' || z == 'x' || z == 'z'|| z == 'm' || z == 'n' || z == 'k') then ( s_temp := (VarTable.add (x) (VarTable.find (z) (!s_temp)) (!s_temp))) else Printf.printf "Can't be done"; )
| 'Q' -> (match y with NUM(z) -> if (x == 'a' || x == 'b' || x == 'c' || x == 'w' || x == 'x' || x == 'z') then (q_temp := (VarTable.add (x) (z) (!q_temp))) else Printf.printf "Can't be done"; 
	| VAR(z) -> if (z == 'a' || z == 'b' || z == 'c' || z == 'w' || z == 'x' || z == 'z') then ( q_temp := (VarTable.add (x) (VarTable.find (z) (!q_temp)) (!q_temp))) else Printf.printf "Can't be done"; )
| 'U' -> (match y with NUM(z) -> if (x == 'a' || x == 'b' || x == 'c' || x == 'w' || x == 'x' || x == 'z' || x == 'p' || x == 'g') then (u_temp := (VarTable.add (x) (z) (!u_temp))) else Printf.printf "Can't be done"; 
	| VAR(z) -> if (z == 'a' || z == 'b' || z == 'c' || z == 'w' || z == 'x' || z == 'z' || z == 'p' || z == 'g' ) then ( u_temp := (VarTable.add (x) (VarTable.find (z) (!u_temp)) (!u_temp))) else Printf.printf "Can't be done"; )
| 'T' -> (match y with NUM(z) -> if (x == 'a' || x == 'b' || x == 'c' || x == 'w' || x == 'x' || x == 'z' || x == 'y' || x == 'i' || x == 'f') then (t_temp := (VarTable.add (x) (z) (!t_temp))) else Printf.printf "Can't be done"; 
	| VAR(z) -> if (z == 'a' || z == 'b' || z == 'c' || z == 'w' || z == 'x' || z == 'z' || z == 'y' || z == 'i' || z == 'f') then (t_temp := (VarTable.add (x) (VarTable.find (z) (!t_temp)) (!t_temp))) else Printf.printf "Can't be done"; )
| 'W' -> (match y with NUM(z) -> if (x == 'a' || x == 'b' || x == 'c' || x == 'w' || x == 'x' || x == 'z' || x == 'm' || x == 'p' || x == 'j' ) then (w_temp := (VarTable.add (x) (z) (!w_temp))) else Printf.printf "Can't be done"; 
	| VAR(z) -> if (z == 'a' || z == 'b' || z == 'c' || z == 'w' || z == 'x' || z == 'z' || z == 'm' || z == 'p' || z == 'j' ) then (w_temp := (VarTable.add (x) (VarTable.find (z) (!w_temp)) (!w_temp))) else Printf.printf "Can't be done"; ) )) 

	| Call(FUNC(x),Tup(p,q)) ->( match (!l) with a :: b ->  ( match a with 'M' ->   if (x == 'M' || x == 'Q' || x == 'P') then (q_temp := VarTable.map f !temp;p_temp := VarTable.map f !temp;l := (x :: (!l));st := (x :: (!st))) else Printf.printf " Can't be called " ; 
|'P' ->   if (x == 'M' || x == 'Q' || x == 'P' || x == 'R' || x == 'S' || x == 'V') then (r_temp := VarTable.map f !p_temp;l := (x :: (!l));st := (x :: (!st));eval_tree (Assign(VAR('x'),p));eval_tree (Assign(VAR('y'),q))) (*(eval_tree (Assign(VAR('x'),p))); (eval_tree (Assign(VAR('y'),q))); *) else Printf.printf " Can't be called " ; 
| 'Q' -> if (x == 'M' || x == 'P' || x == 'Q' || x == 'T' || x == 'U') then (t_temp := VarTable.map f !q_temp;l := (x :: (!l));st := (x :: (!st));eval_tree (Assign(VAR('z'),p));eval_tree (Assign(VAR('w'),q))) else Printf.printf " Can't be called " ;
| 'R' -> if (x == 'M' || x == 'Q' || x == 'P' || x == 'R' || x == 'V' ) then (v_temp := VarTable.map f !r_temp;l := (x :: (!l));st := (x :: (!st));eval_tree (Assign(VAR('w'),p));eval_tree (Assign(VAR('i'),q))) else Printf.printf " Can't be called " ;
| 'S' -> if (x == 'M' || x == 'Q' || x == 'P' || x == 'R' || x == 'V' ) then (l := (x :: (!l));st := (x :: (!st));eval_tree (Assign(VAR('c'),p));eval_tree (Assign(VAR('k'),q))) else Printf.printf " Can't be called " ;
| 'V' -> if (x == 'R' || x == 'Q' || x == 'P' || x == 'S' || x == 'M' || x == 'V') then (l := (x :: (!l));st := (x :: (!st));eval_tree (Assign(VAR('m'),p));eval_tree (Assign(VAR('n'),q))) else Printf.printf " Can't be called " ;
| 'U' -> if (x == 'T' || x == 'Q' || x == 'P'|| x == 'M' || x == 'U') then (l := (x :: (!l));st := (x :: (!st));eval_tree (Assign(VAR('c'),p));eval_tree (Assign(VAR('z'),q))) else Printf.printf " Can't be called " ;
| 'T' -> if (x == 'M' || x == 'Q'|| x == 'P'|| x == 'U' || x == 'T' || x == 'W') then (w_temp := VarTable.map f !t_temp;l := (x :: (!l));st := (x :: (!st));eval_tree (Assign(VAR('a'),p));eval_tree (Assign(VAR('y'),q))) else Printf.printf " Can't be called " ;
| 'W' -> if (x == 'U' || x == 'Q' || x == 'P' || x == 'T' || x == 'M' || x == 'W') then (l := (x :: (!l));st := (x :: (!st));eval_tree (Assign(VAR('m'),p));eval_tree (Assign(VAR('p'),q))) else Printf.printf " Can't be called " ;))
| RETURN -> ( match !l with p :: q -> ( match p with 'P' ->  (l:= q;st := p :: q;p_temp := ETable.map f !e_temp)
|'Q' ->  (l:= q;st := p :: q;q_temp := ETable.map f !e_temp)
|'R' ->  (l:= q;st := p :: q;r_temp := ETable.map f !e_temp)
|'S' ->  (l:= q;st := p :: q;s_temp := ETable.map f !e_temp)
|'T' ->  (l:= q;st := p :: q;t_temp := ETable.map f !e_temp)
|'U' ->  (l:= q;st := p :: q;u_temp := ETable.map f !e_temp)
|'V' ->  (l:= q;st := p :: q;v_temp := ETable.map f !e_temp)
|'W' ->  (l:= q;st := p :: q;w_temp := ETable.map f !e_temp) ))
;;
  
(*module FunTable = Map.Make(String)
let fun_set = FunTable.(empty);;
let func = ref fun_set;;*)
(* Function to evaluate value given the parse tree *)
let check t = match t with 
| Display(NUM(1)) ->   ( match (!l) with p :: q -> (match p with  'M' -> prr (VarTable.bindings !temp)(*Printf.printf "a: " ; print_int (VarTable.find ('a') (! temp)); Printf.printf " b: " ; print_int (VarTable.find ('b') (! temp)); Printf.printf " c: " ; print_int (VarTable.find ('c') (! temp))  ;   *)
| 'P' -> prr (VarTable.bindings !p_temp)
| 'Q' -> prr (VarTable.bindings !q_temp)
| 'R' -> prr (VarTable.bindings !r_temp)
| 'S' -> prr (VarTable.bindings !s_temp)
| 'T' -> prr (VarTable.bindings !t_temp)
| 'U' -> prr (VarTable.bindings !u_temp)
| 'V' -> prr (VarTable.bindings !v_temp)
| 'W' -> prr (VarTable.bindings !w_temp) )) 
| Display(NUM(2)) -> pr (!st) 
| Display(NUM(3)) -> ( match (!l) with p :: q -> (match p with  'M' -> Printf.printf "Main,Q,P ";
|'P' -> Printf.printf "Q,Main,R,S,P ";
|'R' -> Printf.printf "P,Q,Main,R,S,V ";
|'V' -> Printf.printf "R,P,Q,S,Main,V ";  
|'Q' -> Printf.printf "P,Main,Q,T,U, ";  
|'U' -> Printf.printf "T,P,Q,Main,U ";
| 'S' ->   Printf.printf "P,Q,Main,R,S ";
|'T' -> Printf.printf "Q,U,P,Main,T,W " ;
| 'W' -> Printf.printf "Q,U,P,T,Main,W "; ))
| Display(NUM(4)) -> ( match (!l) with p :: q -> (match p with  'M' -> Printf.printf "a,b,c ";
|'P' -> Printf.printf "a,z,x,y,b,c ";
|'R' -> Printf.printf "a,z,x,y,b,c,w,i,j ";
|'V' -> Printf.printf " m,n,a,z,x,y,b,c,w,i,j";  
|'Q' -> Printf.printf "a,b,c,z,w,x ";  
|'U' -> Printf.printf "p,g,a,b,c,z,w,x ";
| 'S' ->   Printf.printf "a,z,x,y,b,c,m,n,k ";
|'T' -> Printf.printf "a,b,c,z,w,x,y,i,f " ;
| 'W' -> Printf.printf "m,p,j,h,a,b,c,z,w,x "; ))
| Display(NUM(5)) -> ( match (!l) with p :: q -> (match p with  'M' -> Printf.printf "M ";
|'P' -> Printf.printf "M ";
|'R' -> Printf.printf "M,P ";
|'V' -> Printf.printf "M,P,R ";  
|'Q' -> Printf.printf "M ";  
|'U' -> Printf.printf "M,Q ";
| 'S' ->   Printf.printf "M,P ";
|'T' -> Printf.printf "M,Q " ;
| 'W' -> Printf.printf "M,Q,T "; ))
| _ -> eval_tree t
;;


(*
let rec eval_tree t = match t with
    NULL           -> raise Empty
    | NUM(x)       -> x
    | INTO(t1,t2)  -> (eval_tree t1) * (eval_tree t2)
    | PLUS(t1,t2)  -> (eval_tree t1) + (eval_tree t2)
    | VAR(x)       -> VarTable.find x variable_set
;;

 Function to print the expression tree, each node labelled with its level/depth 
let rec print_tree t level = match t with
    NULL           -> Printf.printf "Empty Tree\n";
    | NUM(x)       -> Printf.printf "Level %d INT %d " level x;
    | INTO(t1,t2)  -> Printf.printf "Level %d *\n" level; print_tree t1 (level+1); print_tree t2 (level+1); print_newline();
    | PLUS(t1,t2)  -> Printf.printf "Level %d +\n" level; print_tree t1 (level+1); print_tree t2 (level+1); print_newline();
    | VAR(x)       -> Printf.printf "Level %d INT %d " level (VarTable.find x variable_set);
;;
 TODO
 * - Try writing a compile function that converts given parse tree into a postfix code.
 *    You might have to define a new type
 * - Try evaluating compiled expression tree using stack machine
 * *)
